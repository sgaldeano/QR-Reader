import 'dart:io';

import 'package:path_provider/path_provider.dart';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart' show join;
import '../models/models.dart' show QRCodeScan;

class DBProvider {

  static const String _databaseName = 'QRCodeScansDB.db';
  static const String _scansTable = 'Scans';

  static Database? _database;
  static final DBProvider instance = DBProvider._();

  DBProvider._();

  Future<Database> get database async {
    if (_database != null) return _database!;

    _database = await initDatabase();
    return _database!;
  }

  Future<Database> initDatabase() async {
    //Path where we are going to save the Database
    Directory documentsDirectory = await getApplicationDocumentsDirectory();
    final databasePath = join(documentsDirectory.path, _databaseName);
    print(databasePath);

    //Database creation
    return await openDatabase(
      databasePath,
      version: 1,
      onOpen: (Database database) {},
      onCreate: (Database database, int version) async {
        await database.execute(
        '''
          CREATE TABLE '$_scansTable'(
            id INTEGER PRIMARY KEY,
            type TEXT,
            value TEXT
          )
        '''
        );
      }
    );
  }

  //INSERT long implementation
  Future<int> insertScanRawLong(QRCodeScan scan) async {
    final id = scan.id;
    final type = scan.type;
    final value = scan.value;

    final db = await database;

    final response = await db.rawInsert(
      '''
        INSERT INTO '$_scansTable'(id, type, value)
          VALUES($id, '$type', '$value')
      '''
    );

    //result is the autogenerated id of the last register that was inserted
    return response;
  }

  //INSERT short implementation
  Future<int> insertScanRaw(QRCodeScan scan) async {
    final db = await database;
    final response = await db.insert(_scansTable, scan.toJson());

    print(response);

    //result is the autogenerated id of the last register that was inserted
    return response;
  }

  //QUERY a register in the database table "Scans"
  //where: 'id = ?' also can be 'where: 'id = ? and otherThing = ?' and this will allow
  //to send more arguments in the whereArgs list of the query. The whereArgs must receive
  //the arguments in the 'where' string in the same order that appears separated by 'and'.
  Future<QRCodeScan?> getScanById(int searchedId) async {
    final db = await database;

    final List<Map<String, dynamic>> res = await db.query(_scansTable, where: 'id = ?', whereArgs: [searchedId]);

    return res.isNotEmpty
      ? QRCodeScan.fromJson(res.first)
      : null;
  }

  Future<List<QRCodeScan>> getAllScans() async {
    final db = await database;

    final List<Map<String, dynamic>> res = await db.query(_scansTable);

    return res.isNotEmpty
      ? res.map((json) => QRCodeScan.fromJson(json)).toList()
      : [];
  }

  Future<List<QRCodeScan>> getScansByType(String type) async {
    final db = await database;

    final List<Map<String, dynamic>> res = await db.rawQuery(
      '''
        SELECT * FROM '$_scansTable' WHERE type = '$type'
      '''
    );

    return res.isNotEmpty
      ? res.map((json) => QRCodeScan.fromJson(json)).toList()
      : [];
  }

  Future<int> updateScan(QRCodeScan scan) async {
    final db = await database;

    return await db.update(_scansTable, scan.toJson(), where: 'id = ?', whereArgs: [scan.id]);
  }

  Future<int> deleteScan(int id) async {
    final db = await database;

    return await db.delete(_scansTable, where: 'id = ?', whereArgs: [id]);
  }

  Future<int> deleteAllScans() async {
    final db = await database;

    return await db.delete(_scansTable);
  }

  Future<int> rawDeleteAllScans() async {
    final db = await database;

    return await db.rawDelete(
      '''
        DELETE FROM '$_scansTable'
      '''
    );
  }

}